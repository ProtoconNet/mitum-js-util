/*
    mitum-js-util SDK for mitum-currency, mitum-document
    Copyright (C) 2021-2022 ProtoconNet

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

const { BaseKey } = require('./base');

// util, error
const { _hint, parseTyped, sum256, BigInteger } = require('../util');
const { ValidationError } = require('../errors');

// hint
const { MC_KEY, MC_KEYS, MC_ADDRESS } = require('../hint');

// encode
const bs58 = require('bs58');


function keyCompare(x, y) {
    return Buffer.compare(x.key._buffer(), y.key._buffer());
};


class Key {

    constructor(key, w) {
        if(w < 1 || w > 100) {
            throw new RangeError(`weight < 1 or weight > 100 :: Key; weight is in the invalid range. valid: 1 <= weight <= 100.`);
        }

        this.hint = _hint(MC_KEY);
        this.key = new BaseKey(key, 'unknown');
        this.weight = new BigInteger(w.toString());
    }

    buffer() {
        return Buffer.concat(
            [this.key.buffer(), this.weight.buffer()]
        );
    }

    dict() {
        const key = {};
        key._hint = this.hint;
        key.weight = this.weight.value;
        key.key = this.key.typed();
        return key;
    }
};


class Keys {

    constructor(keys, threshold) {
        if(threshold < 1 || threshold > 100) {
            throw new RangeError(`threshold < 1 or threshold > 100 :: Keys; threshold is in the invalid range. valid: 1 <= threshold <= 100.`);
        }

        this.hint = _hint(MC_KEYS);
        this.keys = keys;
        this.threshold = new BigInteger(threshold.toString());
        this.hash = this._generateHash();
    }

    /**
     * @returns {string} Address generated by keys, and threshold
     */
    get address() {
        return bs58.encode(this.hash) + MC_ADDRESS;
    }

    buffer() {
        const bKeys = Buffer.concat(this.keys.sort(keyCompare).map(x => x.buffer()));
        const bThreshold = this.threshold.buffer();

        return Buffer.concat([bKeys, bThreshold]);
    }

    dict() {
        const keys = {};
        keys._hint = this.hint;
        keys.hash = bs58.encode(this.hash);
        keys.keys = this.keys.map(x => x.dict());
        keys.threshold = this.threshold.value;

        return keys;
    }

    _generateHash() {
        return sum256(this.buffer());
    }
};


class Address {

    constructor(addr) {
        let parsed = parseTyped(addr);

        this.type = parsed.type;
        this.addr = parsed.raw;

        if (this.type !== MC_ADDRESS) {
            throw new ValidationError(`suffix !== ${MC_ADDRESS} :: Address; Invalid typed address.`);
        }
    }

    buffer() {
        return Buffer.from(this.typed());
    }

    typed() {
        return this.addr + this.type;
    }
};


module.exports = {
    Key,
    Keys,
    Address
};